(*RECEIVED EXTENSION*)
open Num
let ni = num_of_int
(******************************************PART A******************************************)
(*A.1*)
(*
  The space complexity of the tree-recursive fibonacci function 
  using applicative-order evaluation is O(N) because the function 
  creates a call stack of size n, with n being the input number and this 
  stack grows with each recursive call hence adding 
  a new frame for each call. By the problem statement we know that 
  when a call completes, the frame is removed 
  from the call stack therefore the maximum size of the call stack is n,
  our input number. Basically as we calculate all of fib(n) before fib(n-1)
  therefore the call stack will never have more than n items
  on it sequence  This is differs from time complexity, O(2^N), 
  because time complexity accounts for the number of operations a function 
  performs to reach a result, whereas space complexity accounts for the amount 
  of memory used by our function. Here, our function performs a large number of 
  operations, however it utilizes only a small amount of memory on the stack.
*)
(*A.2*)
(*
  1. 
  The function p is applied 5 times because 12.15 /. 3.0 = 4.05 and as we take 
  the ceiling of that (round it up) to a whole number because we can't run 0.05 of 
  a proccess and 4 is too small to make the angle small enough hence we need a full fifth run.
  2.
  The order of growth in space generated by the sine function when sine a is evaluated 
  (as a function of a) is proportional to the number of steps because each additonal step
  results in a recursive calling creating a new stack frame to execute on which will be O(log N.
  The order of growth in number of steps used by the process generated by the sine function when 
  sine a is evaluated (as a function of a) is O(log(base 3)(N)) because "sine" is called 
  recursively and the input value is divided by 3 on each recursive call hence making the number of 
  calls on p 3^N with N being the number of steps hence we can just solve for N to get our answer.
*)
(*A.3.a*)
let rec fast_expt b n =
  let is_even m = m mod 2 = 0 in
  let square m = m * m in
    match n with
    |0 -> 1
    |_ when is_even n -> square (fast_expt b (n / 2))
    |_ -> b * fast_expt b (n - 1)

(*A.3.b*)
let ifast_expt b n =
  let is_even m = m mod 2 = 0 in
  let square_num m = m * m in 
  let rec iter b n result = 
    match n with
    |0 -> result
    |_ when is_even n -> iter (square_num b) (n / 2) result
    |_ -> iter (square_num b) (n / 2) (result * b) 
  in
  iter b n 1

(*A.4*)
let rec fast_mult a b =
  let is_even m = m mod 2 = 0 in 
  let double m = 2 * m in  
  let halve m = m / 2 in
  match b with
  |0 -> 0
  |_ when (is_even b && is_even a) -> fast_mult (double a) (halve b)
  |_ -> a + (fast_mult a (b - 1))

(*A.5*)
let ifast_mult a b = 
  let is_even m = m mod 2 = 0 in 
  let double m = m * 2 in 
  let halve m = m / 2 in 
  let rec iter a b result =
    match b with
    |0 -> result
    |_ when (is_even b && is_even a) -> iter (double a) (halve b) result
    |_ -> iter a (b - 1) (result + a)
  in
  iter a b 0;;

(*A.6*)
(*
   The worst case space complexity for this algorithm is O(log N) because we
   are halving N with each ietration until we reach N <= 1 therefore giving it
   logrithmic space complexity behaviour as we are only creating log (N) stack frames
   because we are in applicative-order evaluation hence it will recurse on the operands first
   hence it will recurse on the first foo function call which will take O(log N) space because
   it is halving N each time until N <=1 then the stack will clean up after itself before evaluating
   the second foo call hence we will never have more than o(log N) stack frames.
   The time complexity for this is O(N) because we have two recursive calls on N that 
   halve N each time until N <= 1 therefore 2 function calls with logrithmic time 
   due to evalution in applicative order as mentioned for space complexity hence 
   O(2 ^ log_2(N)) = O(N). f is negligable in this worst case time/space calcultaion as it
   is constant for both.
*)
(*A.7*)
(*1.
  This function is linear recurssive because it calls itself once and then last_two a recursive helper linearly many
  times with n - 1 until we reach our base case hence all levels of recursion are pending until the base case
  where it folds back up hence using a input that is always one step closer istead of multiple steps
  at once.
  2. 
  The space complexity of this function O(N) because it is linearly recursive hence there are N stack frames
  created. The space complexity is also O(N) because again it's linearly recursive as it takes one step closer
  to the base case with each function call hence making N many calls.
*)
(******************************************PART B******************************************)
(*B.1.a*)
(fun x y -> (x * (2 + y))) 20 (2 * 4);;
(*B.1.b*)
(fun a b c -> sqrt (b *. b -. 4.0 *. a *. c)) 1.0 20.0 3.0;;
(*B.1.c*)
(fun x -> (fun y -> (fun z -> x * y * z) 3) 2) 1;;
(*B.1.d*)
(fun x -> (fun x -> (fun x -> x * x * x) 3) 2) 1;;
(*B.2*)
(*
  Desugar to:
  (fun x y -> (fun y z -> x * y * z)14 22) (2 * 10) (3 + 4)
  Evaluate: 2 * 10
  * evaluate 2 -> 2
  * evaluate 10 -> 5
  * evaluate * operator -> (primitive function * )
  * apply * operator to 2 10 -> 20
  Evaluate: 3 + 4
  * evaluate 3 -> 3
  * evaluate 4 -> 4
  * evaluate + operator -> (primitive function +)
  * apply + operator to 3 4 -> 7
  Evaluate: (fun x y -> (fun y z -> x * y * z)14 22) 20 7
  * evaluate (fun y z -> x * y * z) 14 22
    * evaluate 22 -> 22
    * evaluate 14 -> 14
    substitute 14 for y and 22 for z into x * y * z -> x * 14 * 22
    * evaluate x * 14 * 22
    * evaluate 22 -> 22
    * evaluate 14 -> 14
    * evaluate x -> x
    * evaluate * operator -> (primitive function * )
    * apply * operator to 22 14 x -> 308x
  * evaluate (fun x y -> 308x) 20 7
    substitute 7 for y and 20 for x into 308x -> 308 * 20
    * evaluate 308 -> 308
    * evaluate 20 -> 20
    * evaluate * operator -> (primitive function * )
    * apply * operator to 308 20 -> 6160
  Therefore our result is: 6160

(*B.3*)
(*
  Desugar to:
  (fun x y z -> x + y + z) 10 (x * 2) (y + 3)) 
  This code will not work because the function arguments are evaluated first in our 
  substitution model hence it:
  * evaluate 10 -> 10 
  however, when it tries to evaluate (x * 2), it runs into the unbound value 
  for x  because x is not defined/bounded yet so it cannot perform the * operation
  on x as it does not know what x is. To fix this, Ben should change all his and
  statements (because he would run into the same error for y also on line 3) 
  to "in let" so that lines 2 and 3 become functions that apply x and y respectfully.
  Therefore:
    let x = 10
    in let y = x * 2
    in let z = y + 3
    in x + y + z
  Desugared: 
    (fun x -> (fun y -> (fun z -> x + y + z) (y + 3))(x * 2))10;;

*)
*)
(******************************************PART C******************************************)
(*C.1*)
let isum term a next b =
  let rec iter a result =
    if a >/ b
       then result
       else iter (next a) (result +/ term a)
  in
    iter a (ni 0)

(*C.2*)
let rec product_rec term a next b =
  if a >/ b then (ni 1) else
    (term a) */ product_rec term (next a) next b

let product_iter term a next b =
  let rec iter a result =
    if a >/ b then result else
      iter (next a) (result */ term a)
  in 
  iter a (ni 1)

let factorial_rec n =
  if n </ (ni 0) then invalid_arg "Invalid Input n" else
    product_rec (fun x -> x) (ni 1) (fun x -> x +/ (ni 1)) n

  let factorial_iter n =
    if n </ (ni 0) then invalid_arg "Invalid Input n" else
      product_iter (fun x -> x) (ni 1) (fun x -> x +/ (ni 1)) n

let pi_product n =
  ((ni 2) */ n */ ((ni 2) */ n +/ (ni 2)) // (((ni 2) */ n +/ (ni 1)) **/ (ni 2)))

let pi_approx = float_of_num((product_iter pi_product (ni 1) (fun x -> x +/ (ni 1)) (ni 1500)) */ (ni 4))

(*C.3*)
let rec accumulate_rec combiner null_value term a next b =
  if a >/ b then null_value else
    combiner (term a) (accumulate_rec combiner null_value term (next a) next b)

let accumulate_iter combiner null_value term a next b =
  let rec iter a result =
    if a >/ b then result else
      iter (next a) (combiner (term a) (result))
    in 
    iter a null_value

let sum term a next b = accumulate_rec (+/) (ni 0) term a next b
let product term a next b= accumulate_iter ( */ ) (ni 1) term a next b

(*C.4*)
let compose f g =
  fun x -> f (g (x))

(*C.5*)
let rec repeated f n =
  match n with
  |0 -> fun x -> x 
  |1 -> f
  |_ when n < 0 -> invalid_arg "Invalid Input n"
  |_ -> compose f (repeated f (n - 1))
    

(*C.6*)
let smooth dx f x = 
  (f(x -. dx) +. f(x) +. f(x +. dx)) /. 3.0

let nsmoothed dx f n =
  repeated (smooth dx) n f
(******************************************PART D******************************************)
(*D.1*)
let is_prime (n: int) = 
  if n < 2 then false else
    let rec iter (i: int) =
      if i * i > n then true else
        n mod i != 0 && iter (i + 1)
    in
    iter 2

(*D.2*)
let smallest_prime_factor (n: int) =
   if is_prime n = true then invalid_arg "Invalid Input n" else
    let rec iter (i: int) =
      match i with
      |_ when ((is_prime i = true) && (n mod i = 0)) -> i
      |_ -> iter (i + 1)
    in 
    iter 2




